#+BEGIN_SRC emacs-lisp :results silent :exports none
    (unless (find "kc-report" org-latex-classes :key 'car
                  :test 'equal))

  (add-to-list 'org-latex-classes
               '("kc-report"
                 "\\documentclass[11pt,a4paper]{scrreprt}
  \\usepackage[T1]{fontenc}
  \\usepackage{fontspec}
  \\usepackage{graphicx}
  \\defaultfontfeatures{Mapping=tex-text}
  \\setromanfont{Charis SIL}
  \\setsansfont{Gentium Plus}
  \\setmonofont[Scale=0.8]{DejaVu Sans Mono}
  \\usepackage{geometry}
        [NO-DEFAULT-PACKAGES]
        [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    (setq org-latex-pdf-process
    '("latexmk -xelatex -interaction=nonstopmode -pdf %f"))
#+END_SRC

#+AUTHOR: Christoph Hegemann
#+TITLE: Verwendung des Messaging Systems Kafka zur Entkopplung von Microservices
#+LATEX_CLASS: kc-report
# #+LATEX_CLASS_OPTIONS: [a4paper, oneside, abstract=true, BCOR=11pt, fontsize=11pt, draft=true, titlepage=false, headsepline=true]
#+LATEX_CLASS_OPTIONS: [a4paper, oneside, abstract=true, BCOR=11pt, fontsize=12pt, draft=false, titlepage=true, headsepline=true]
#+LATEX_HEADER: \usepackage[hyperref,x11names]{xcolor}
#+LATEX_HEADER: \usepackage[colorlinks=true,urlcolor=SteelBlue4,linkcolor=Firebrick4]{hyperref}
#+LATEX_HEADER: \usepackage[normalem]{ulem}
#+LATEX_HEADER: \usepackage[ngerman]{babel}
#+LATEX_HEADER: \usepackage{csquotes}
#+LATEX_HEADER: \setcounter{tocdepth}{1}
#+LATEX_HEADER: \setcounter{secnumdepth}{1}
#+LATEX_HEADER: \pagestyle{headings}
#+LATEX_HEADER: \usepackage[backend=biber, style=science, backref=true]{biblatex}
#+LATEX_HEADER: \addbibresource{literatur.bib}
#+BIBLIOGRAPHY: literatur.bib
#+LANGUAGE: de
#+OPTIONS: H:4 ':t

#+BEGIN_abstract
  Das wichtigste Prinzip in der Entwicklung einer Microservice Architektur ist,
  dass zwischen den einzelnen Services so wenige Abhängigkeiten wie nur möglich
  bestehen.
  Eine weiteres grundlegendes Prinzip ist "Don't share the database". Jeder
  Service muss also die Daten, die er benötigt um zu funktionieren, selbst
  speichern.asd
  Natürlich arbeiten die verschiedenen Services jedoch häufig auf den selben
  Entitäten, sodass hier eine Synchronisation stattfinden muss.
  Wie können nun also mehrere Services mit den selben Entitäten arbeiten?
#+END_abstract

* Motivation
** Microservice Architektur
*** Domain Driven Design 
    Eric Evans cite:Evans-DomainDrivenDesign
*** Conways Law - Melvin Conway
    organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations
*** Microservice Definition
    "Microservices are small, autonomous services that work together" cite:Newman-BuildingMicroservices

** "Don't share the database"
** Message Broker
*** Apache Kafka
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    A high-throughput distributed messaging system

    - Partitionierter Commit Log
    - Verteilt. Also mehrere Instanzen
    - CAP Theorem
      - Consistency
      - Availability
      - +Partition Tolerance+
*** RabbitMQ/ActiveMQ
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

* Infrastruktur und Provisionierung
** Anforderungen
*** Elastizität
    Ein Message Broker wie Kafka kann zu verschiedenen Zeiten unter variierender
    Last arbeiten haben. Zu Stoßzeiten werden sehr viele Services Messages
    produzieren und abrufen. Um diesen sich ändernden Anforderungen gerecht zu
    werden, muss Kafka so aufgesetzt werden, dass dynamisch neue Broker
    hinzugefügt oder heruntergefahren werden können.
*** Automatisierung
    Die Provisionierung einer Maschine mit einem Kafka Broker muss vollständig
    automatisch ablaufen. Dies steht in direktem Bezug zu /Elastizität/ und dem
    Prinzip der Automatisierung von Microservices.
*** Resilienz
    Die Message Queue stellt einen /Single Point of Failure/ dar. Sollte sie
    ausfallen können die Services nicht miteinander kommunizieren und die
    Verfügbarkeit des Gesamtsystems kann nicht sichergestellt werden. Daher
    müssen Fallback Instanzen provisioniert werden, die einspringen wenn
    Ausfälle auftreten. Weiterhin müssen ausgefallene Instanzen automatisch
    neugestartet und provisioniert werden.

** Docker/Container Technologie
** Monitoring?


* Der Prototyp
** Produktservice
   Der Produktservice ist Owner des Produkt Topics. Er stellt eine API zur
   Verfügung, die es erlaubt Produktdaten zu ändern. In unserem Protoyp werden
   diese Änderungen zufällig generiert.

*** Modell
    Der Produktservice hat folgende Sicht auf die Produktentität:

    #+BEGIN_SRC haskell
      data Produkt =
        Produkt
        { id :: String
        , name :: String
        , beschreibung :: String
        , preis :: Preis
        , rabatt :: Prozent
        }
    #+END_SRC
    #+CAPTION: Produkt Modell des Produktservices
    Updates, die der Produktservice an Kafka schickt, enthalten eine Payload in
    dieser Form.

** Warenkorbservice

   Der Warenkorbservice ist Owner für kein Topic. Stattdessen verwaltet er die
   Warenkörbe der Kunden, die für die restlichen Services nicht zur Verfügung
   stehen.

*** Modell
    Der Warenkorbservice hat folgende Sicht auf die Produktentität:
    #+BEGIN_SRC haskell
      data Produkt =
        Produkt
        { id :: String
        , name :: String
        , preis :: Preis
        }
    #+END_SRC
    #+CAPTION: Produkt Modell des Warenkorbservices
    Hierbei fällt auf, dass der Warenkorb nur an einem Subset der Felder der
    Produktservice Produktentität Kafka interessiert ist. Weiterhin beschreibt
    das ~preis~ Attribut den Preis, auf den der Rabatt bereits angewendet wurde.

    Es wird also eine /Selektion/ auf die vorhandenen Felder angewendet, und die
    verbleibenden Felder werden weiter durch /Transformation/ & /Aggregation/ in
    ein Modell, das der Domäne des Warenkorbes[fn:artikel] entspricht,
    transformiert.

[fn:artikel]
In Wirklichkeit ist der Begriff des *Preises* im E-Commerce noch
deutlich komplexer. Einem *Produkt* ist zunächst einmal gar kein Preis
zugewiesen. Stattdessen ist ein Produkt eine Einheit, die für die
Präsentation verwendet wird (zB. Kaffetasse). \\
Einen Preis hingegen weist man einem *Artikel* zu, der Elemente wie Art (zB.
Farbe), Region (Produkte haben in unterschiedlichen Regionen unterschiedliche
Preise) und Rabattaktionen beinhaltet.

*** API
    Der Warenkorbservice bietet die folgenden Operationen für das Bearbeiten von
    Warenkörben an.

**** Warenkorb anlegen
     Legt einen neuen Warenkorb an und gibt die ~id~ des Warenkorbes zurück

**** Artikel hinzufügen
     Fügt einem bestehenden Warenkorb einen Artikel in der angegebenen Quantität
     hinzu.
**** Bestellung erstellen
     Weist den Warenkorbservice an, eine Bestellung aus einem bestehenden
     Warenkorb zu erstellen und an einen eventuellen Checkoutservice
     weiterzureichen.


* Fazit
\printbibliography
